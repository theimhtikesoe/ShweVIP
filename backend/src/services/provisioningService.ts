import { randomBytes } from "node:crypto";
import { readFile, rm, writeFile } from "node:fs/promises";
import { join } from "node:path";
import { tmpdir } from "node:os";
import { NodeSSH } from "node-ssh";
import { env } from "../config/env";
import { DataRepository } from "../repositories/repository";

export class ProvisioningService {
  constructor(private readonly repository: DataRepository) {}

  private buildConfig(userId: number, serverIp: string): string {
    const privateKey = randomBytes(32).toString("base64");
    const publicKey = randomBytes(32).toString("base64");

    // This template keeps generated configs consistent across auto/manual provisioning.
    return [
      "# Auto-generated by PNM",
      `[Interface]`,
      `PrivateKey = ${privateKey}`,
      "Address = 10.10.0.2/32",
      "DNS = 1.1.1.1",
      "",
      "[Peer]",
      `PublicKey = ${publicKey}`,
      `Endpoint = ${serverIp}:51820`,
      "AllowedIPs = 0.0.0.0/0",
      "PersistentKeepalive = 25",
      `# User ID: ${userId}`
    ].join("\n");
  }

  async provisionUser(userId: number, serverId: number): Promise<{ configText: string }> {
    const user = await this.repository.getUserById(userId);
    if (!user) {
      throw new Error(`User ${userId} not found`);
    }

    const server = await this.repository.getServerById(serverId);
    if (!server) {
      throw new Error(`Server ${serverId} not found`);
    }

    const configText = this.buildConfig(user.id, server.ip);

    if (env.PROVISION_DRY_RUN) {
      console.log(`[DRY_RUN] Provisioning user ${user.id} on ${server.ip}`);
    } else {
      await this.pushConfigToServer(user.id, server.ip, configText);
    }

    await this.repository.saveUserConfig(user.id, server.id, configText);
    await this.repository.createTunnelSession(user.id, server.id, 0);

    return { configText };
  }

  private async pushConfigToServer(userId: number, host: string, configText: string): Promise<void> {
    const ssh = new NodeSSH();
    const tempFile = join(tmpdir(), `pnm-user-${userId}-${Date.now()}.conf`);
    const privateKey = await readFile(env.PROVISION_SSH_PRIVATE_KEY, "utf8");

    try {
      await writeFile(tempFile, configText, "utf8");

      await ssh.connect({
        host,
        username: env.PROVISION_SSH_USER,
        privateKey
      });

      const remotePath = `/etc/wireguard/clients/user-${userId}.conf`;
      await ssh.putFile(tempFile, remotePath);
      await ssh.execCommand(`chmod 600 ${remotePath} && ${env.PROVISION_SERVICE_RELOAD_CMD}`);
    } finally {
      ssh.dispose();
      await rm(tempFile, { force: true });
    }
  }
}
