import { randomBytes } from "node:crypto";
import { readFile, rm, writeFile } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import { NodeSSH } from "node-ssh";
import nacl from "tweetnacl";
import { env } from "../config/env";
import { DataRepository } from "../repositories/repository";

function toBase64(value: Uint8Array): string {
  return Buffer.from(value).toString("base64");
}

function fromBase64(value: string): Uint8Array {
  return new Uint8Array(Buffer.from(value, "base64"));
}

function shellQuote(value: string): string {
  return `'${value.replace(/'/g, `'"'"'`)}'`;
}

function extractPrivateKey(configText: string): string | null {
  const match = configText.match(/^PrivateKey\s*=\s*(.+)$/m);
  return match?.[1]?.trim() ?? null;
}

function derivePublicKey(privateKey: string): string {
  const keyPair = nacl.box.keyPair.fromSecretKey(fromBase64(privateKey));
  return toBase64(keyPair.publicKey);
}

function generateClientKeyPair(): { privateKey: string; publicKey: string } {
  const keyPair = nacl.box.keyPair();
  return {
    privateKey: toBase64(keyPair.secretKey),
    publicKey: toBase64(keyPair.publicKey)
  };
}

function buildClientAddress(userId: number): string {
  const prefixParts = env.WG_CLIENT_NETWORK_PREFIX.split(".").map((part) => Number(part));
  if (
    prefixParts.length !== 2 ||
    prefixParts.some((part) => Number.isNaN(part) || part < 0 || part > 255)
  ) {
    throw new Error("WG_CLIENT_NETWORK_PREFIX must be two octets, for example 10.10");
  }

  const hostOffset = env.WG_CLIENT_HOST_OFFSET;
  if (hostOffset < 2 || hostOffset > 254) {
    throw new Error("WG_CLIENT_HOST_OFFSET must be between 2 and 254");
  }

  // Map user IDs into a predictable /16 client pool for stable reprovisioning.
  const slotsPerSubnet = 254 - hostOffset + 1;
  const index = userId - 1;
  const thirdOctet = Math.floor(index / slotsPerSubnet);
  const fourthOctet = hostOffset + (index % slotsPerSubnet);

  if (thirdOctet > 255) {
    throw new Error("Client IP pool exhausted for WG_CLIENT_NETWORK_PREFIX");
  }

  return `${prefixParts[0]}.${prefixParts[1]}.${thirdOctet}.${fourthOctet}/32`;
}

function resolveServerEndpoint(serverIp: string): string {
  if (env.WG_SERVER_ENDPOINT) {
    return env.WG_SERVER_ENDPOINT.includes(":")
      ? env.WG_SERVER_ENDPOINT
      : `${env.WG_SERVER_ENDPOINT}:${env.WG_SERVER_PORT}`;
  }

  return `${serverIp}:${env.WG_SERVER_PORT}`;
}

export class ProvisioningService {
  constructor(private readonly repository: DataRepository) {}

  private buildConfig(
    userId: number,
    serverIp: string,
    clientPrivateKey: string,
    clientAddress: string
  ): string {
    const serverPublicKey =
      env.WG_SERVER_PUBLIC_KEY ?? toBase64(randomBytes(32));

    return [
      "# Auto-generated by PNM",
      "[Interface]",
      `PrivateKey = ${clientPrivateKey}`,
      `Address = ${clientAddress}`,
      `DNS = ${env.WG_DNS}`,
      "",
      "[Peer]",
      `PublicKey = ${serverPublicKey}`,
      `Endpoint = ${resolveServerEndpoint(serverIp)}`,
      `AllowedIPs = ${env.WG_ALLOWED_IPS}`,
      `PersistentKeepalive = ${env.WG_PERSISTENT_KEEPALIVE}`,
      `# User ID: ${userId}`
    ].join("\n");
  }

  async provisionUser(userId: number, serverId: number): Promise<{ configText: string }> {
    const user = await this.repository.getUserById(userId);
    if (!user) {
      throw new Error(`User ${userId} not found`);
    }

    const server = await this.repository.getServerById(serverId);
    if (!server) {
      throw new Error(`Server ${serverId} not found`);
    }

    if (!env.PROVISION_DRY_RUN && !env.WG_SERVER_PUBLIC_KEY) {
      throw new Error("WG_SERVER_PUBLIC_KEY is required when PROVISION_DRY_RUN=false");
    }

    const latestConfig = await this.repository.getLatestUserConfig(user.id);
    const existingPrivateKey = latestConfig
      ? extractPrivateKey(latestConfig.configText)
      : null;

    const keyPair = existingPrivateKey
      ? {
          privateKey: existingPrivateKey,
          publicKey: derivePublicKey(existingPrivateKey)
        }
      : generateClientKeyPair();

    const clientAddress = buildClientAddress(user.id);
    const configText = this.buildConfig(
      user.id,
      server.ip,
      keyPair.privateKey,
      clientAddress
    );

    if (env.PROVISION_DRY_RUN) {
      console.log(
        `[DRY_RUN] Provisioning user ${user.id} on ${server.ip} (${clientAddress})`
      );
    } else {
      await this.pushConfigToServer(
        user.id,
        server.ip,
        configText,
        keyPair.publicKey,
        clientAddress
      );
    }

    await this.repository.saveUserConfig(user.id, server.id, configText);
    await this.repository.createTunnelSession(user.id, server.id, 0);

    return { configText };
  }

  private async resolveSshPrivateKey(): Promise<string> {
    if (env.PROVISION_SSH_PRIVATE_KEY_B64) {
      return Buffer.from(env.PROVISION_SSH_PRIVATE_KEY_B64, "base64").toString("utf8");
    }

    if (env.PROVISION_SSH_PRIVATE_KEY.includes("BEGIN")) {
      return env.PROVISION_SSH_PRIVATE_KEY;
    }

    return readFile(env.PROVISION_SSH_PRIVATE_KEY, "utf8");
  }

  private async pushConfigToServer(
    userId: number,
    host: string,
    configText: string,
    clientPublicKey: string,
    clientAddress: string
  ): Promise<void> {
    const ssh = new NodeSSH();
    const tempFile = join(tmpdir(), `pnm-user-${userId}-${Date.now()}.conf`);
    const privateKey = await this.resolveSshPrivateKey();

    try {
      await writeFile(tempFile, configText, "utf8");

      await ssh.connect({
        host,
        username: env.PROVISION_SSH_USER,
        privateKey
      });

      const remotePath = `/etc/wireguard/clients/user-${userId}.conf`;
      await ssh.execCommand("install -d -m 700 /etc/wireguard/clients");
      await ssh.putFile(tempFile, remotePath);

      const ensureInterfaceUp =
        `ip link show ${shellQuote(env.WG_INTERFACE)} >/dev/null 2>&1 || ` +
        `wg-quick up ${shellQuote(env.WG_INTERFACE)}`;
      const setPeer =
        `wg set ${shellQuote(env.WG_INTERFACE)} ` +
        `peer ${shellQuote(clientPublicKey)} ` +
        `allowed-ips ${shellQuote(clientAddress)}`;
      const command = [
        "set -e",
        `chmod 600 ${shellQuote(remotePath)}`,
        ensureInterfaceUp,
        setPeer,
        env.PROVISION_SERVICE_RELOAD_CMD
      ].join(" && ");

      const result = await ssh.execCommand(command);
      if (result.code !== 0) {
        throw new Error(result.stderr || "Failed to apply WireGuard peer configuration");
      }
    } finally {
      ssh.dispose();
      await rm(tempFile, { force: true });
    }
  }
}
